<!DOCTYPE html>
<html>
<head>
    <title>3D Chess Game with STL Export</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/stlExporter/babylon.stlExporter.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
    <canvas id="gameCanvas" style="width: 100%; height: 100%;"></canvas>
    <button id="exportSTL" style="position: absolute; top: 15px; left: 15px;">Download STL</button>
    <script>
        const gameCanvas = document.getElementById("gameCanvas");
        const engine = new BABYLON.Engine(gameCanvas, true);
        let activePiece = null;
        let currentTurn = new BABYLON.Color3(1, 1, 1);

        const initializeScene = () => {
            const scene = new BABYLON.Scene(engine);

            // Set up camera
            const cam = new BABYLON.ArcRotateCamera("cam", -Math.PI / 2, Math.PI / 2.5, 15, BABYLON.Vector3.Zero(), scene);
            cam.attachControl(gameCanvas, true);

            // Add light source
            const lighting = new BABYLON.HemisphericLight("lighting", new BABYLON.Vector3(0, 1, 0), scene);

            // Create chessboard tiles
            const boardSize = 8, tileSize = 1;
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const tile = BABYLON.MeshBuilder.CreateBox(`tile_${row}_${col}`, { size: tileSize }, scene);
                    tile.position = new BABYLON.Vector3(row - boardSize / 2 + 0.5, 0, col - boardSize / 2 + 0.5);
                    const tileMaterial = new BABYLON.StandardMaterial(`tileMaterial_${row}_${col}`, scene);
                    tileMaterial.diffuseColor = (row + col) % 2 === 0 ? new BABYLON.Color3(1, 1, 1) : new BABYLON.Color3(0, 0, 0);
                    tile.material = tileMaterial;
                }
            }

            return scene;
        };

        const scene = initializeScene();
        const piecesArray = [];

        const createChessPiece = (type, position, color) => {
            let pieceMesh;
            switch (type) {
                case "pawn":
                    pieceMesh = BABYLON.MeshBuilder.CreateSphere(type, { diameter: 0.5 }, scene);
                    break;
                case "rook":
                    pieceMesh = BABYLON.MeshBuilder.CreateBox(type, { size: 0.5 }, scene);
                    break;
                case "knight":
                    pieceMesh = BABYLON.MeshBuilder.CreateCylinder(type, { diameter: 0.5, height: 1 }, scene);
                    break;
                case "bishop":
                    pieceMesh = BABYLON.MeshBuilder.CreateTorus(type, { diameter: 0.5, thickness: 0.15 }, scene);
                    break;
                case "queen":
                    pieceMesh = BABYLON.MeshBuilder.CreateCylinder(type, { diameter: 0.6, height: 1.2 }, scene);
                    break;
                case "king":
                    pieceMesh = BABYLON.MeshBuilder.CreateCylinder(type, { diameter: 0.6, height: 1.3 }, scene);
                    break;
                default:
                    pieceMesh = BABYLON.MeshBuilder.CreateBox(type, { size: 0.5 }, scene);
            }

            pieceMesh.position = position;
            const material = new BABYLON.StandardMaterial(type + "Material", scene);
            material.diffuseColor = color;
            pieceMesh.material = material;
            pieceMesh.actionManager = new BABYLON.ActionManager(scene);
            pieceMesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
                activePiece = pieceMesh;
            }));

            return pieceMesh;
        };

        // Setup pieces and initial positions
        for (let i = 0; i < 8; i++) {
            piecesArray.push(createChessPiece("pawn", new BABYLON.Vector3(i - 3.5, 0.5, 2.5), new BABYLON.Color3(1, 1, 1)));
            piecesArray.push(createChessPiece("pawn", new BABYLON.Vector3(i - 3.5, 0.5, -2.5), new BABYLON.Color3(0.3, 0.3, 0.3)));
        }
        
        const toggleTurn = () => {
            currentTurn = currentTurn.equals(new BABYLON.Color3(1, 1, 1)) ? new BABYLON.Color3(0.3, 0.3, 0.3) : new BABYLON.Color3(1, 1, 1);
        };

        // Add STL export functionality
        document.getElementById("exportSTL").addEventListener("click", () => {
            const allPieces = piecesArray.concat(scene.meshes);
            BABYLON.STLExport.CreateSTL(allPieces, false, "chessboard_export", engine);
        });

        // Add turn display
        var uiTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        var turnText = new BABYLON.GUI.TextBlock();
        turnText.text = "White's Turn";
        turnText.color = "white";
        turnText.fontSize = 24;
        turnText.top = "-45px";
        uiTexture.addControl(turnText);

        scene.onPointerDown = (evt, pickResult) => {
            if (activePiece && activePiece.material.diffuseColor.equals(currentTurn)) {
                const clickedTile = pickResult.pickedMesh;
                if (clickedTile && canMove(activePiece, clickedTile)) {
                    const x = clickedTile.position.x;
                    const z = clickedTile.position.z;
                    activePiece.position = new BABYLON.Vector3(x, 0.5, z);
                    toggleTurn();
                    turnText.text = currentTurn.equals(new BABYLON.Color3(1, 1, 1)) ? "White's Turn" : "Black's Turn";
                    activePiece = null;
                }
            }
        };

        function canMove(piece, destination) {
            // Movement logic for each piece goes here
            // Returns true if piece can move to the destination, otherwise false
            return true; // Placeholder logic
        }

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>
